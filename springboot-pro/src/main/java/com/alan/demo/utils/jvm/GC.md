## GC

````
1.GC 是什么(分代搜集算法)?

次数上频繁收集Young区

次数上较少收集Old区

基本上不动元空间

````

````
2.GC算法
JVM在进行GC时,并非每次都对Eden from To  Old 内存区域一起回收,大部分回收的都是指新生代。
因此GC按照回收的区域又分为了两种类型,一种是普通GC(minor GC)，一种是全局GC(major GC or Full GC)

Minor GC和Full GC的区别

普通GC(minor GC): 只针对新生代区域的GC,只发生在新生代的垃圾收集动作,因为大多数Java对象存活率都不高,
所以Minor GC非常频繁，一般回收速度也比较快。

全局GC(major GC or Full GC)：只发生在老年代的垃圾收集动作,出现了Major GC，经常会伴随至少一次的
Minor GC(但并不是绝对的)。 Major GC速度一般要比Minor GC慢上10倍以上


四大算法
1) 引用计数法
缺点:
  1.每次对对象赋值时均需要引用计数器,且计数器本身也有一定的消耗;
  2.较难处理循环引用
  JVM的实现一般不采取这种方式


2) 复制算法(Copying)
Minor GC会把Eden中的所有活的对象都移到Survivor区域中,如果Survivor区中放不下,那么剩下的
活的对象就被移到Old generation中,也即一旦收集后,Eden是就变成空的了.
当对象在Eden(包括一个Survivor区域,这里假设是from区域)出生后,在经过一次Minor GC之后,如果对象还存活,并且能够被
另外一块Survivor区域所容纳(上面已经假设为from区域,这里应为to区域,即to区域有足够的内存空间来存储Eden和from区域中存活的对象),
则使用复制算法将这些仍然还存活的对象复制到另外一块Survivor区域(即to区域)中,然后清理所使用过的Eden以及Survivor区域(即from区域),
并且将这些对象的年龄设置为1,以后对象在Survivor区每熬过一次 Minor GC,就将对象的年龄+1,当对象的年龄达到某个值时(默认是15岁,通过-XX:MaxTenuringThreshold来设定参数),
这些对象就会成为老年代。

-XX:MaxTenuringThreshold --设置对象在新生代中存活的次数

优点: 无碎片

复制算法它的缺点也是相当明显的。
1.它浪费了一般的内存空间,这太要命了。
2.如果对象的存活率很高,我们可以极端一点,假设是100%存活,那么我们需要将所有的对象都复制一遍,并将所有引用地址重置一遍。复制这一工作所花费的时间
在对象存活率达到一定程度时,将会变得不可忽视。所以从以上描述不难看出,复制算法要想使用，最起码对象的存活率要非常低才行,而且最重要的是,我们必须要克服
50%内存的浪费。

3) 标记清除(Mark-Sweep)
发生在老年代
优点: 不需要额外的空间
缺点: 会产生内存碎片

详细解释->
  1.首先,它的缺点就是效率比较低(递归与全堆对象遍历),而且在进行GC的时候,需要停止应用程序,这会导致用户体验非常差劲
  2.其次,主要的缺点则是这种方式清理出来的空闲内存是不连续的,这点不难理解,我们的死亡对象都是随即的出现在内存的各个角落的,现在把它们清除之后,
   内存的布局自然会乱七八遭,而为了应付这一点,JVM就不得不维持一个内存的空闲列表,这又是一种开销,而且在分配数组对象的时候,寻找连续的内存空间会不太好找

4) 标记压缩(Mark-Compact)
 比标记清除多了一次扫描  移动对象 减少内存碎片    较耗时
 
 可以看出,效率上来说,复制算法是当之无愧的老大,但是却浪费了太多内存,而为了尽量兼顾上面所提到的三个指标,
 标记/整理算法 相对来说更平滑一些,但效率上依然不尽人意,它比复制算法多了一个标记的阶段,又比标记/清除多了一个整理内存的过程
 

````
